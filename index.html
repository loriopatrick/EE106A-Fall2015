<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>EE 106A Batting Robot</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>EE 106A Batting Robot</h1>
        <br/>
      </header>
      <section>
<h3 class="c2 c5"><a name="h.mke4q0y6oylk"></a><span>Introduction</span></h3><p class="c2"><span class="c0">The goal of this project was to develop a batting robot which can hit a ball to a target held by a user. To achieve our goal, we did the following</span><span class="c0">:</span></p><ul class="c1 lst-kix_6mt1qbm7zagy-0 start"><li class="c8 c2"><span class="c0">setup up and configure the motors and sensors on the double pendulum</span></li><li class="c8 c2"><span class="c0">build a ball dropping mechanism</span></li></ul><ul class="c1 lst-kix_zh08oos2qat1-0 start"><li class="c8 c2"><span class="c0">build a sensing system to determine the target position</span></li><li class="c8 c2"><span class="c0">develop software to control the hardware with low latency</span></li><li class="c8 c2"><span class="c0">build a model for the system&rsquo;s dynamics</span></li><li class="c8 c2"><span class="c0">experiment with varying initial configurations and discover ball&rsquo;s final location</span></li><li class="c8 c2"><span class="c0">develop a system to determine batting plan given the target height</span></li></ul><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">We have found similar robots from other universities designed to hit a ball. For example, a robot developed at CMU with several degree of freedoms can imitate a human&rsquo;s batting motion. Another robotic manipulator developed at Univ. of Tokyo is able to capture and predict a ball&rsquo;s motion with high speed camera to hit a ball robustly.</span></p><p class="c2"><span class="c0">What makes our project interesting is that we are concerned about the trajectory of the ball after we hit it.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Using the knowledge acquired from this project::: :D:SF :DF If we know the impact dynamics between a robot and a ball, then it may be possible to develop a partner robot to play sports. Baxter may be your sports partner in the near future.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The lessons learnt from developing the low latency control software and binary protocols could be used in many future real world projects. The dynamics developed for the double pendulum could be useful for future projects on our hardware. A robot of this sort has real world applications in the entertainment industry</span></p><p class="c2 c4"><span class="c0"></span></p><h3 class="c2 c5"><a name="h.c91e55lrukoj"></a><span>Design</span></h3><p class="c2"><span class="c0">The robot should be able to: (i) detect the position of the target, (ii) formulate a plan for hitting the ball to the target, and (iii) have the ability to hit the ball to the target. This should work by having a user interface with a graphical program. When a target is visible to the robot, the interface should allow you to send a &ldquo;target&rdquo; command. The robot will then calculate the batting plan and move to the initial position for that plan. When at the initial position, the interface should then allow the user to send a &ldquo;fire&rdquo; command. The robot will then complete the batting plan and hit the ball to the target.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">In (ii) we planned to simulate our mathematical model of the double pendulum to optimize the parameters for batting the ball to the target height. However we were unable to account for all the dynamics of our system. Our theoretical results differed enough from our experimental values that we went with a different approach. Instead of simulating the dynamics at runtime and finding the batting parameters, we precomputed parameters that hit the ball to varying heights. We then tested those parameters and put their experimental values of target heights into a lookup table. With this, during planning stage we simply find the experiment that hit the ball closest to the desired target height and use its parameters for the batting plan.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">[something about how design led to robust solution]</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><h3 class="c2 c5"><a name="h.d98qdq787hp7"></a><span>Implementation</span></h3><p class="c2"><span class="c0">We used an arduino uno to interface with the motor drivers, encoders, and ball dropping servo. The arduino communicated to a laptop through serial communication that controlled the entire system. In addition to the arduino, the laptop was also connected to a webcam which was used for detecting the target.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 399.00px; height: 313.00px;"><img alt="" src="images/image36.png" style="width: 399.00px; height: 319.00px; margin-left: 0.00px; margin-top: -6.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c0"></span></p><h5 class="c2 c5"><a name="h.hfbxssliwm4q"></a><span>Sensing</span></h5><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The sensing algorithm was written using OpenCV. When the robot boots it takes a reference photo. During operation, the system computes the difference between new images from the reference photo. Each pixel in the reference photo is put through a hand tuned threshold to compute a binary mask displaying the new parts of the image in white. Using OpenCV&rsquo;s contour detection algorithm we detect the shape with the largest area in the sensing region (outlined in green in last image) and consider it our target. We then use a linear mapping to determine the real world height of the object from the pixel location.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 740.61px; height: 163.17px;"><img alt="" src="images/image41.png" style="width: 740.61px; height: 163.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c0"></span></p><h5 class="c2 c5"><a name="h.ro3ref8kvcq5"></a><span>Interfacing</span></h5><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The arduino was used as a bridge between the laptop and hardware. We used hardware interrupts on the arduino to detect the size of the pulse modulated signals from the encoders. Using this technique after trying pulseIn we lowered the encoder&rsquo;s error from 2 degrees to 0.75 and got a higher rate of communication as pulseIn, by design, waits for a whole wave from the encoder to be received. For the ball dropping mechanic we used the built in servo library to move the servo between 90 and 0 degrees to open and close the ball drop. To control the double pendulum the arduino sent 3 signals to each motor driver. The first two encoded the direction to apply torque to the motor. The third sent a varying 0-5 volts to the motor driver which mapped to 0-5 and 0-4 amps on the elbow and shoulder motors respectively.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The arduino communicated to the laptop over the serial usb cable. We tried several different protocols but arrived at using a continuous stream of information separated by a unique sequence of bytes that cannot occur in the data payload. Both the laptop and arduino wait for the unique sequence of bytes then read and decode the payload. The payload from arduino to server consists of:</span></p><ul class="c1 lst-kix_gzbqvm485cit-0 start"><li class="c8 c2"><span class="c0">5 header bytes (0000)</span></li></ul><ul class="c1 lst-kix_5ahz2kpcvk7a-0 start"><li class="c8 c2"><span class="c0">4 byte timestamp</span></li><li class="c8 c2"><span class="c0">1 byte padding (1)</span></li><li class="c8 c2"><span class="c0">2 byte shoulder angle (0-359)</span></li><li class="c8 c2"><span class="c0">2 byte current reading from elbow motor driver</span></li><li class="c8 c2"><span class="c0">1 byte padding (1)</span></li><li class="c8 c2"><span class="c0">2 byte elbow angle (0-359)</span></li><li class="c8 c2"><span class="c0">2 byte current reading from should motor driver</span></li><li class="c2 c8"><span class="c0">1 byte padding (1)</span></li></ul><p class="c2"><span class="c0">the payload from laptop to arduino consists of:</span></p><ul class="c1 lst-kix_ob3032jfvakv-0 start"><li class="c8 c2"><span class="c0">1 header byte (0)</span></li></ul><ul class="c1 lst-kix_unhdvjl6uoex-0 start"><li class="c8 c2"><span class="c0">1 byte shoulder direction (clockwise/counter clockwise/off)</span></li><li class="c8 c2"><span class="c0">1 byte padding (1 if shoulder current = 0, 2 otherwise)</span></li><li class="c8 c2"><span class="c0">1 byte shoulder current (1-255)</span></li><li class="c8 c2"><span class="c0">1 byte elbow direction (clockwise/counter clockwise/off)</span></li><li class="c8 c2"><span class="c0">1 byte padding (1 if elbow current = 0, 2 otherwise)</span></li><li class="c8 c2"><span class="c0">1 byte elbow current (1-255)</span></li><li class="c8 c2"><span class="c0">1 byte ball drop (open = 1, closed = 2)</span></li></ul><p class="c2"><span class="c0">Using this protocol we were are able to achieve a communication rate of ~300Hz and control the entire system from a laptop.</span></p><p class="c2 c4"><span class="c0"></span></p><h5 class="c2 c5"><a name="h.eb0ujoc39nf"></a><span>Executing Batting Plan</span></h5><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The batting plan consists of 5 parameters</span></p><ul class="c1 lst-kix_iop07dtroci1-0 start"><li class="c8 c2"><span class="c0">drop time</span></li><li class="c8 c2"><span class="c0">shoulder angle</span></li><li class="c8 c2"><span class="c0">elbow angle</span></li><li class="c8 c2"><span class="c0">elbow direction</span></li><li class="c8 c2"><span class="c0">should direction</span></li></ul><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The batting plan is executed in a simple state machine. The state transitions through SET_START_ANGLE, WAITING_FOR_DROP, WAITING_FOR_POS, BATTING, and DONE.</span></p><p class="c2 c4"><span class="c0"></span></p><h6 class="c2 c5"><a name="h.by4s82a4os19"></a><span>SET_START_ANGLE</span></h6><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">In SET_START_ANGLE we use shoulder and elbow elbow angles from the batting plan to move to the initial configuration. We do this with the controller derived below.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The dynamics of double pendulum can be written as follows;</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 324.49px; height: 35.17px;"><img alt="" src="images/image39.png" style="width: 324.49px; height: 35.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">where,</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.93px; height: 45.42px;"><img alt="" src="images/image45.png" style="width: 566.93px; height: 45.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 566.93px; height: 43.61px;"><img alt="" src="images/image40.png" style="width: 566.93px; height: 43.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 567.00px; height: 33.33px;"><img alt="" src="images/image31.png" style="width: 567.00px; height: 49.01px; margin-left: 0.00px; margin-top: -15.68px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 41.70px; height: 23.17px;"><img alt="" src="images/image39.png" style="width: 215.83px; height: 23.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c0">To control our robot we tried to compensate for nonlinear terms with a feedforward controller s.t.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 360.22px; height: 159.55px;"><img alt="" src="images/image42.png" style="width: 360.22px; height: 159.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">where,</span></p><p class="c2 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 196.81px; height: 21.09px;"><img alt="" src="images/image44.png" style="width: 196.81px; height: 21.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 82.33px; height: 19.00px;"><img alt="" src="images/image43.png" style="width: 82.33px; height: 19.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c11"><img src="images/image00.png"><span class="c0">&nbsp;is a nominal torque constant</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c0">We found that angular velocities sometimes showed large values due to noise, therefore, we neglect </span><img src="images/image01.png"><span class="c0">&nbsp;term in our trials. </span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Then, we tried to identify a plant model with the frequency response method. Since motors have a large damping factor due to the belts which connect motor and robot arm, we cannot assume the model which only includes inertias of the robot arm. According to the results, we modeled the plant as a 2</span><span class="c0 c10">nd</span><span class="c0">&nbsp;order system.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Elbow:</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 342.00px; height: 263.33px;"><img alt="" src="images/image32.png" style="width: 342.00px; height: 268.00px; margin-left: 0.00px; margin-top: -4.67px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c15"><span class="c7 c3">red: data points from experiments</span></p><p class="c2 c15"><span class="c7 c3">blue: estimated line modeled as a 2</span><span class="c7 c10 c3">nd</span><span class="c3 c7">&nbsp;order system</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 215.75px; height: 34.02px;"><img alt="" src="images/image37.png" style="width: 612.38px; height: 34.02px; margin-left: -199.38px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2"><span class="c3">S</span><span class="c0">houlder:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 335.00px; height: 259.00px;"><img alt="" src="images/image30.png" style="width: 335.00px; height: 265.00px; margin-left: 0.00px; margin-top: -6.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c15"><span class="c7 c3">Red: data points from experiments</span></p><p class="c2 c15"><span class="c7 c3">Blue: estimated line modeled as a 2</span><span class="c7 c3 c10">nd</span><span class="c7 c3">&nbsp;order system</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.03px; height: 34.02px;"><img alt="" src="images/image35.png" style="width: 422.61px; height: 34.02px; margin-left: -87.82px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Based on this data, we set the PI controller </span><img src="images/image02.png"><span class="c0">&nbsp;such that;</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 116.45px; height: 32.77px;"><img alt="" src="images/image47.png" style="width: 116.45px; height: 32.77px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">And tuned</span><img src="images/image03.png"><span class="c0">&nbsp;and </span><img src="images/image03.png"><span class="c0">&nbsp;through simulation and experiments.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Once both the shoulder and elbow are within 5 degrees of the target angles we move to the next state WAITING_FOR_DROP.</span></p><p class="c2 c4"><span class="c3"></span></p><p class="c2 c4"><span class="c3"></span></p><h6 class="c2 c5"><a name="h.wqsx87vbxkfc"></a><span>WAITING_FOR_DROP</span></h6><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">In WAITING_FOR_DROP we wait for the user to send the fire command then move to the WAITING_FOR_POS state. In the WAITING_FOR_POS we apply the controller form SET_START_ANGLE and once both joints are within 5 degrees of the target we move to the BATTING state. The WAIT_FOR_DROP state can be arbitrarily long and joint angles may have changed by outside factors. By having this state we add more robustness to the system.</span></p><p class="c2 c4"><span class="c0"></span></p><h6 class="c2 c5"><a name="h.cqdwfk4ymybx"></a><span>BATTING</span></h6><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">During the batting phase we start a stopwatch and set the starting time to the batting plan&rsquo;s drop time. We also set the ball drop the to open position to start the ball in a free fall. When the stopwatch time is positive, we apply maximum torque on both motors in the direction specified by the batting plan&rsquo;s shoulder and elbow direction. When either the shoulder or elbow angles go past a specific threshold we move to the DONE state.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Below is the mathematical model that describes the batting phase given the batting plan. Simulating the mathematical at varying initial configuration gave us different parameters to try in our experiments which we added to the lookup table.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Inputting the maximum torque to the motors, we found two initial configurations, which enable the robot to hit a ball to the target at any height. At these configurations, we changed only the ball drop time in order to tune both contact angle and velocity of robot arm at the contact point. The simulation calculate the ball&rsquo;s height given one of the configurations and the ball drop time. Procedures of the simulation is as follows:</span></p><p class="c2 c4"><span class="c0"></span></p><ul class="c1 lst-kix_rzyntxsokmxq-0 start"><li class="c8 c2"><span class="c0">Log experimental trajectory of robot arm according to time</span></li><li class="c8 c2"><span class="c0">Estimate contact timing, contact joint and the velocity at the contact point</span></li><li class="c8 c2"><span class="c0">Estimate height that the ball reach in the end</span></li></ul><p class="c2 c4"><span class="c0 c12"></span></p><p class="c2"><span class="c0">To develop the simulation, for the first step, we logged trajectories of the robot.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 314.38px; height: 283.46px;"><img alt="" src="images/image28.png" style="width: 314.38px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6 c9"><span class="c7 c3">Fig. Over hand case, black points: trajectory of hand, red points trajectory of elbow</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 314.30px; height: 283.46px;"><img alt="" src="images/image34.png" style="width: 314.30px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6 c9"><span class="c7 c3">Fig. Under hand case, black points: trajectory of hand , red points trajectory of elbow</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Estimate contact timing, contact joint and the velocity at the contact point</span></p><p class="c2"><span class="c0">Then, we estimate contact angle and contact velocity. We set a simulation time as follows:</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">A ball drops at time </span><img src="images/image04.png"><span class="c0">[sec]</span></p><p class="c2"><span class="c0">Robot arm actuates at time </span><img src="images/image05.png"><span class="c0">[sec]</span></p><p class="c2"><span class="c0">The ball and arm contacts at time </span><img src="images/image06.png"><span class="c0">[sec]</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><img src="images/image07.png"><span class="c0">&nbsp;is a control parameter that we need to define. </span><img src="images/image08.png"><span class="c0">&nbsp;is derived from the following calculations. </span></p><p class="c2"><span class="c0">With these time stamps, we can predict the position of the ball at </span><img src="images/image06.png"><span class="c0">&nbsp;since it is free fall.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><img src="images/image09.png"><span class="c0">&nbsp;</span></p><p class="c2"><img src="images/image10.png"><span class="c0">&nbsp;</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">As we logged the position of robot arm according to time, we can also estimate the position of robot arm at </span><img src="images/image06.png"><span class="c0">. </span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><img src="images/image11.png"><span class="c0">&nbsp;</span></p><p class="c2"><img src="images/image12.png"><span class="c0">&nbsp;</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The contact timing </span><img src="images/image06.png"><span class="c0">&nbsp;will be the time at which the difference between </span><img src="images/image13.png"><span class="c0">&nbsp;and </span><img src="images/image14.png"><span class="c0">&nbsp;becomes the smallest, therefore, </span></p><p class="c2"><img src="images/image15.png"></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">where </span><img src="images/image16.png"><span class="c0">&nbsp;is a radius of tennis ball as a physical system cannot assume to be a point. With this time </span><img src="images/image06.png"><span class="c0">, we can find a contact angle and contact velocity.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 312.07px; height: 283.46px;"><img alt="" src="images/image46.png" style="width: 312.07px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6 c9"><span class="c7 c3">Fig. Over hand case, blue point shows the position of the ball at time </span><img src="images/image06.png"><span class="c7 c3">, </span><img src="images/image17.png"><span class="c7 c3">[sec], </span><img src="images/image18.png"><span class="c7 c3">[deg], </span><img src="images/image19.png"><span class="c7 c3">, </span><img src="images/image20.png"></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 313.44px; height: 283.46px;"><img alt="" src="images/image29.png" style="width: 313.44px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6 c9"><span class="c7 c3">Fig. under hand case, blue point shows the position of the ball at time </span><img src="images/image06.png"><span class="c7 c3">, </span><img src="images/image17.png"><span class="c7 c3">[sec], </span><img src="images/image21.png"><span class="c7 c3">&nbsp;36.1[deg], </span><img src="images/image22.png"><span class="c7 c3">, </span><img src="images/image23.png"></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c2 c4"><span class="c0"></span></p><ol class="c1 lst-kix_list_21-0 start" start="1"><li class="c2 c17"><span class="c0">Estimate height that the ball reach in the end</span></li></ol><p class="c2"><span class="c0">Based on basic dynamics, velocity of the ball after impact can be expressed as follows.</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><img src="images/image24.png"><span class="c0">&nbsp;</span></p><p class="c2"><img src="images/image25.png"><span class="c0">&nbsp;</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">We set </span><img src="images/image26.png"><span class="c0">&nbsp;for coefficient of resitution of a tennis ball. With these velocities, we can estimate the heights. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 314.45px; height: 283.46px;"><img alt="" src="images/image27.png" style="width: 314.45px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c6 c9"><span class="c7 c3">Fig. Over hand case, blue points show the position of the ball. The estimated height is 1.3[m].</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 314.45px; height: 283.46px;"><img alt="" src="images/image48.png" style="width: 314.45px; height: 283.46px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6 c9"><span class="c7 c3">Fig. Under hand case, blue points show the position of the ball. The estimated height is 0.95[m].</span></p><p class="c2 c4"><span class="c0"></span></p><h6 class="c2 c5"><a name="h.xtiajz7h0c96"></a><span>DONE</span></h6><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">In the done state we stop applying torque to both motors.</span></p><p class="c2 c4"><span class="c0"></span></p><h5 class="c2 c5"><a name="h.sfccnt8gxzw6"></a><span>Result</span></h5><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">&lt;Insert Movie, maybe better to edit movie to have three height&gt;</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The robot successfully hit the ball to the target suggested a user. We could not measure the height of the ball, so we could not analyze our system qualitatively. However, as you can see from the video, the robot can hit to the target regardless of its height. </span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><h5 class="c2 c5"><a name="h.r4ct39im1232"></a><span>Hardware</span></h5><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 378.07px; height: 251.17px;"><img alt="" src="images/image33.png" style="width: 378.07px; height: 251.17px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 261.55px; height: 215.17px;"><img alt="" src="images/image38.jpg" style="width: 381.80px; height: 215.17px; margin-left: -50.84px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"><br></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">The double pendulum was built by ****</span></p><p class="c2 c4"><span class="c0"></span></p><h6 class="c2 c5"><a name="h.cpf87joqklav"></a><span>Double pendulum&rsquo;s Hardware</span></h6><ul class="c1 lst-kix_2oeujynj9dxv-0 start"><li class="c8 c2"><span class="c0">Motors<br>Elbow: EC-max 40 &phi;40mm, blushless, 70watt, with Hall sensors</span><span class="c0">, MAXON<br></span><span class="c0">Shoulder: EC 60 flat&phi;60mm, blushless, 100watt, without cover</span><span class="c0">, MAXON<br></span><span class="c0">Both motors are connected to motor driver ESCON50/5, MAXON</span></li></ul><ul class="c1 lst-kix_4ijiq8u40slx-0 start"><li class="c8 c2"><span class="c0">Encoder (Elbow &amp; Shoulder):<br>MA-3-P12, US Digital</span></li></ul><p class="c2 c4"><span class="c0"></span></p><h6 class="c2 c5"><a name="h.58uoocz5e61t"></a><span>Our Hardware</span></h6><ul class="c1 lst-kix_z0gf1ch45oih-0 start"><li class="c8 c2"><span class="c0">Ball drop mechanism:<br>3d printed chassis with a Towerpro Sg90 9g Micro Servo</span></li></ul><ul class="c1 lst-kix_dfzrs1iiz6wp-0 start"><li class="c8 c2"><span class="c0">Arduino</span></li></ul><ul class="c1 lst-kix_u2s9q4j80xeu-0 start"><li class="c8 c2"><span class="c0">Laptop</span></li></ul><p class="c2 c4"><span class="c0"></span></p><p class="c2 c4"><span class="c0"></span></p><h3 class="c2 c5"><a name="h.mckr538m8xm1"></a><span>Conclusion</span></h3><p class="c4 c6"><span class="c12 c14"></span></p><p class="c6"><span>As shown in the results, we could successfully hit a ball to the target, which is our goal of this project. We tried several trials and confirmed that the robot is able to hit the target repeatedly with an accuracy of more than 60%. If we developed a paddle at the contact point, then the accuracy would increase. However, there are still large room to improve its accuracy. In our experiments, we used relatively large object as the target (the object&rsquo;s radius is about 20[cm]). We checked whether the ball hit the target or not, but we could not confirm the actual height the ball reached in the end. We assume that the actual height was not precisely controlled. Through some more experiments, it may be better to update our map which shows the relationship between the timing to drop a ball and the height a ball will reach in the end. </span></p><p class="c4 c6"><span class="c12 c14"></span></p><p class="c6"><span>There is a variety of problems when we worked on this project. The biggest problem in hardware was that we could not actuate motors as we desired. At the beginning, we tried to control the distance (horizontal distance) of a ball after batting instead of the height (vertical distance). Although we tried several configurations (e.g. hitting like tennis serve) to increase a velocity at a contact point, but they did not work well. In the end, we noticed that the angular velocity of the motor might be saturated. We learned that it is important to know the specification and characteristics of hardware to meet our objective. The biggest problem in software is to control robot arm to hit a ball to the appropriate height. We did simulation with basic dynamics to estimate the height, but we found that the simulation results did not fit to the actual measurement results. Therefore, we tried to achieve our goal through some trial &amp; error. It was a good experience to learn that theory does not always match reality. </span></p><p class="c4 c6"><span class="c12 c14"></span></p><p class="c4 c6"><span class="c12 c14"></span></p><p class="c6"><span class="c13">As we mentioned, we built a map </span><span>which shows the relationship between the timing to drop a ball and the height a ball will reach in the end. In this project, we tried to build it by trial and error, however, it might be able to remodel impact dynamics in order to improve our simulation and to control the height of a ball more precisely. On the other hand, it may be interesting to make robot learn how to hit a ball precisely by applying reinforcement learning programming to the robot.</span></p><p class="c4 c6"><span class="c13"></span></p><h3 class="c2 c5"><a name="h.6rcr0dfadfkv"></a><span>Team</span></h3><p class="c2 c4"><span class="c0"></span></p><p class="c2"><span class="c0">Daisuke Kaneishi</span></p><p class="c2"><a name="h.23j4wewjiavc"></a><span class="c0">I am a</span><span class="c0">&nbsp;graduate student in the department of mechanical engineering at UC Berkeley.</span><span class="c0">&nbsp;My i</span><span class="c0">nterests include controls of robotics, designs of wearable devices, and human-robot interaction. This class was really interesting for me to learn ROS and basic knowledge for robotics such as FK and IK in exponential expressions. </span></p><p class="c2 c4"><a name="h.l8fqn061nxgn"></a></p><p class="c2"><a name="h.z5lsh2qfvrgg"></a><span class="c0">Patrick Lorio</span></p><p class="c2"><a name="h.o7059vcl0mtw"></a><span class="c0">patrick@loiro.me</span></p><p class="c2"><a name="h.gjdgxs"></a><span class="c0">An undergraduate studying Electrical Engineering and Computer Science at Berkeley.</span></p>
      </section>
      <footer>
        <ul>
          <li><a href="https://github.com/loriopatrick/EE106A-Fall2015/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/loriopatrick/EE106A-Fall2015/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/loriopatrick/EE106A-Fall2015">View On <strong>GitHub</strong></a></li>
        </ul>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
