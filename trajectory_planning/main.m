%% EE206 Optimization part% change the value d below and in fun files according to sensor measurements% all units are in [N],[m],[deg]% be careful about local minima%% clear all%  distance from robot to human measured by sensorsd = 2; %[m]%  initial angle at shoulder measured by sensorsini_theta_sho = 0; %[deg] -> 90 %  initial angle at elbow measured by sensorsini_theta_elb = 0; %[deg] -> 180% sampling frequencyfreq = 100;%[Hz]%% Optimization% initial conditions for optimization% x = [theta_elb, theta_sho, dtheta_elb]x0 = [10, 0, 10];obj_func = @fun;lb = [0;-60;0];ub = [90;60;180];[x, fval] = fmincon(obj_func,x0,[],[],[],[],lb,ub,'constraint');[cin,ceq] = constraint(x);%% confirming resultsg = 9.806; %[m/s^2]phi = x(1) + x(2);% coeff of restitution% we assumed it to be 0.5e = 0.5;% vel in x direction => related to the time that ball reaches human after contact.% should not to be too fast, not too slow.% We chose 36 [km/h] as defaultv_x0 = 10; %[m/s]% reaching time that ball reaches human after contactt_reach = d/v_x0;% height of chest of human % we assume the height as 1.8[m] (height) * 0.75 H = 1.35; %[m]% height at the top of pendulumh = 1.1; %[m]% position of ball dropping point in x-directionb = 0.36; %[m]% length of upper arml_up = 0.29; %[m]% length of fore arml_for = 0.47; %[m]r = (b - l_up*sind(x(2)))/(sind(phi))% time: ball drop - instant of contact t_fall = sqrt(2*(l_up*cosd(x(2)) + r*cosd(phi))/g)v_x0 = r*x(3)*((1+e)*cosd(phi)) + (1+e)*g*t_fall*sind(phi)*cosd(phi)% this equation is derived from impact Dynamicsv_y0 = v_x0*tand(phi) - g*t_fall% for plotsx_sh = 0;y_sh = h;x_el = x_sh + l_up*sind(x(2));y_el = y_sh - l_up*cosd(x(2));x_hand = x_sh + l_up*sind(x(2)) + l_for*sind(phi);y_hand = y_sh - l_up*cosd(x(2)) - l_for*cosd(phi);x_contact = x_sh + l_up*sind(x(2)) + r*sind(phi);y_contact = y_sh - l_up*cosd(x(2)) - r*cosd(phi)X = [x_sh;x_el;x_hand];Y = [y_sh;y_el;y_hand];figure(1)plot(X,Y,'k')hold onplot(x_sh,y_sh,'ro')plot(x_el,y_el,'ro')plot(x_contact,y_contact,'r*')plot([0.36 0.36],[0 1.1],'b:')hold offxlim([-1 1])ylim([0 1.1])cnt = 1;for times = 0:0.01:t_reach    x_ball(cnt) = x_contact + v_x0*times;    %x_ball(cnt) = v_x0*times;    y_ball(cnt) = y_contact - 0.5*g*times^2 + v_y0*times;    cnt = cnt+1;endfigure(2)plot(X,Y,'k','LineWidth',2)hold onplot(x_sh,y_sh,'ro','MarkerSize',10)plot(x_el,y_el,'ro','MarkerSize',10)plot(x_contact,y_contact,'r*','MarkerSize',10)plot([0.36 0.36],[0 1.1],'b:')plot([-0.92 0.92],[1.1 1.1],'k-','LineWidth',2)plot([-1 d+1],[1.35 1.35],'k-.')plot(x_ball,y_ball,'k:')plot(x_ball(end),y_ball(end),'bs','MarkerSize',10)plot([b+d b+d],[0 2],'y-','LineWidth',2)hold offxlim([-1 d+1])ylim([0 2])%% Trajectory planningtheta_elb_opt  = decround(x(1),3);theta_sho_opt  = decround(x(2),3);dtheta_elb_opt = decround(x(3),3);% range of preliminary actionpre_action = 90; %[deg]% time end of pre action & contact timingt_contact = decround(pre_action/dtheta_elb_opt,3);theta_elb_0 = ini_theta_elb + theta_elb_opt - 90;cnt = 1;for i = 0:(1/freq):t_contact + 1        traj_theta_elb(cnt,1) = theta_elb_0 + dtheta_elb_opt*i;    traj_theta_sho(cnt,1) = ini_theta_sho + theta_sho_opt;    cnt = cnt +1;    end% confirmationfor i = 1:cnt-1        traj_x_sh(i,1) = 0;    traj_y_sh(i,1) = h;    traj_x_el(i,1) = x_sh + l_up*sind(traj_theta_sho(i,1));    traj_y_el(i,1) = y_sh - l_up*cosd(traj_theta_sho(i,1));    traj_x_hand(i,1) = x_sh + l_up*sind(traj_theta_sho(i,1)) + l_for*sind(traj_theta_sho(i,1)+traj_theta_elb(i,1));    traj_y_hand(i,1) = y_sh - l_up*cosd(traj_theta_sho(i,1)) - l_for*cosd(traj_theta_sho(i,1)+traj_theta_elb(i,1));    endtrajX = [traj_x_sh traj_x_el traj_x_hand];trajY = [traj_y_sh traj_y_el traj_y_hand];figure(3)plot(x_sh,y_sh,'ro')hold onfor i = 1:cnt-1    trajX = [traj_x_sh(i) traj_x_el(i) traj_x_hand(i)];    trajY = [traj_y_sh(i) traj_y_el(i) traj_y_hand(i)];    plot(trajX,trajY,'k')endplot(x_el,y_el,'ro')plot(x_contact,y_contact,'r*')plot([0.36 0.36],[0 1.1],'b:')hold offxlim([-1 1])ylim([0 1.1])